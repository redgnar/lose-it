# API Endpoint Implementation Plan: Recipe Tailoring

## 1. Endpoint Overview
The `/api/recipes/{id}/tailor` endpoint executes the core value proposition of the application: transforming a recipe to meet specific dietary goals. It performs a two-step process:
1. **Deterministic Scaling**: Adjusts ingredient quantities and step instructions based on the requested `target_servings`.
2. **AI-Driven Reduction**: Uses LLM (Openrouter) to swap ingredients or adjust proportions to reduce calories, guided by the user's `aggressiveness` setting and `avoid_list`.

## 2. Request Details
- **HTTP Method**: POST
- **URL Structure**: `/api/recipes/{id}/tailor`
- **Path Parameters**:
    - `id`: UUID (Required) - The unique identifier of the recipe to tailor.
- **Request Body**:
    ```json
    {
      "target_servings": 2,
      "aggressiveness": "medium",
      "keep_similar": true,
      "save_strategy": "overwrite"
    }
    ```
    - `target_servings`: Integer (1-12)
    - `aggressiveness`: Enum (`low`, `medium`, `high`)
    - `keep_similar`: Boolean (default: true)
    - `save_strategy`: Enum (`overwrite`, `new_version`) - Determines if the active version pointer is updated.

## 3. Used Types
- **Request DTO**: `TailorRecipeCommandDto`
- **Command Model**: `TailorRecipeCommand`
- **Response DTO**: `TailorResultDto`
- **Internal DTOs**:
    - `RecipeVersionMinimalDto` (for representing scaled and final versions)
    - `RecipeIngredientDto`

## 4. Response Details
- **Success (200 OK)**:
  ```json
  {
    "scaled_version": { "id": "uuid", "servings": 2, "ingredients": [] },
    "final_version": { "id": "uuid", "servings": 2, "ingredients": [] },
    "status": "success",
    "message": "Target not achievable; closest estimate shown"
  }
  ```
- **Error Status Codes**:
    - `400 Bad Request`: Validation failure (e.g., servings > 12).
    - `401 Unauthorized`: User not authenticated.
    - `404 Not Found`: Recipe does not exist or does not belong to the user.
    - `422 Unprocessable Entity`: Parse gate failure (active version is less than 80% parsed).
    - `429 Too Many Requests`: User has exceeded their weekly tailoring quota.
    - `500 Internal Server Error`: AI service failure or database error.

## 5. Data Flow
1. **Orchestration**: `TailorRecipeController` receives the request and dispatches `TailorRecipeCommand`.
2. **Quota Check**: `QuotaService` executes an atomic SQL update on `TailoringQuotas`. If the limit is reached, it throws an exception.
3. **Validation**: The `TailoringService` verifies the "Parse Gate": the current active version must have ≥ 80% parsed ingredients and ≤ 2 unknown units.
4. **Step 1 - Scaling**: `ScalingService` calculates new quantities for all scalable ingredients and uses regex to update numeric values in the steps. A new `RecipeVersion` (type: `scale`) is persisted.
5. **Step 2 - Reduction**: `AiReductionService` calls Openrouter.ai with:
    - Scaled ingredient list.
    - User's `avoid_list`.
    - Desired `aggressiveness` and `target_calories_per_serving`.
    - A prompt instructing it to preserve core protein if `keep_similar` is true.
6. **Persistence**: A second `RecipeVersion` (type: `calorie_reduction`) is persisted.
7. **Redundancy Update**: If `save_strategy` is `overwrite`, the `Recipes` table is updated with the new `active_version_id` and the metrics (calories, servings) from the final version.
8. **Logging**: An entry is created in the `Events` table recording the outcome, latency, and status.

## 6. Security Considerations
- **Authentication**: Required via Google OAuth (session-based).
- **Authorization**: Ownership is enforced via Doctrine Filters, ensuring users can only tailor their own recipes.
- **Input Sanitization**: Standard Symfony validation on DTO properties.
- **AI Safety**: The system uses a predefined prompt template to prevent prompt injection and ensure the AI only returns structured ingredient/step data.

## 7. Error Handling
- **Parse Gate Failure**: Returns `422` with details on which ingredients need manual correction.
- **Quota Exceeded**: Returns `429` with information on when the quota resets.
- **AI Timeout (> 8s)**: The system catches the timeout and returns the `scaled_version` with a status message "Calories unavailable; reduction skipped due to timeout".
- **Database Transaction**: All version creations and recipe updates are wrapped in a transaction to ensure consistency.

## 8. Performance Considerations
- **P95 Performance**: Snapshotting metrics in the `Recipes` table ensures fast list/detail reads.
- **AI Latency**: AI calls are the bottleneck. The UI should handle the ~5-10s wait time gracefully.
- **Atomic Updates**: Quota management uses a single `UPDATE` query with conditional logic to avoid race conditions.

## 9. Implementation Steps
1. **Define DTOs**: Create `TailorRecipeCommandDto` and `TailorResultDto` in `app/src/Ux/Http/Recipe/Tailor/`.
2. **Create Command**: Implement `TailorRecipeCommand` and its handler.
3. **Implement Quota Logic**: Add `checkAndIncrementQuota` to `Infrastructure/Service/QuotaService`.
4. **Implement Scaling**:
    - Create `ScalingService` in `Domain/Service`.
    - Logic for quantity multiplication and Step text regex replacement.
5. **Implement AI Reduction**:
    - Create `AiReductionService` in `Infrastructure/Ai`.
    - Integrate with Openrouter.ai client.
    - Define the prompt template.
6. **Persistence Logic**: Implement a service to handle the creation of `RecipeVersion` and `RecipeIngredient` entities, ensuring immutability.
7. **Controller**: Create `TailorRecipeController` to bind the route and DTO.
8. **Testing**:
    - Unit tests for `ScalingService`.
    - Integration tests for Quota logic.
    - Functional API test for the `/tailor` endpoint (mocking the AI call).
