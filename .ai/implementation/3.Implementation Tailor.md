### Implementation Summary

I have completed the foundational logic for the recipe tailoring feature. The implementation now follows a strict **Port-Adapter architecture**, ensuring that the Domain layer remains pure and decoupled from Infrastructure (Doctrine).

**Key achievements:**
1.  **Domain Layer**:
    *   Implemented `ScalingService` with smart regex that scales ingredient quantities while protecting temperatures, cooking times, and step numbers.
    *   Introduced `MeasurementKeywordsProvider` to support multi-language scaling (tested with English and Polish).
    *   Used immutable **Value Objects** for collections (`RecipeIngredientCollection`, `RecipeStepCollection`) and `Uuid` objects for identities.
    *   Enforced strict typing with Enums (`Servings`, `Aggressiveness`, `SaveStrategy`).
2.  **Infrastructure Layer**:
    *   Created `QuotaService` with atomic SQL updates to prevent race conditions in tailoring limits.
    *   Implemented `TailoringService` as an **Adapter** that maps between Doctrine entities and Domain models, orchestrating the scaling process.
3.  **Application Layer**:
    *   Configured **Command Bus** routing for `SyncCommandInterface` and implemented the `TailorRecipeCommand` handler.
4.  **Quality & Testing**:
    *   Achieved 100% pass rate on `make qa`.
    *   Added comprehensive unit tests for `ScalingService` covering edge cases and multi-language support.
    *   Updated architecture tests to validate layer boundaries.

---

### Continuation Prompt

To continue the implementation, you can use the following prompt for the next agent:

```text
I have implemented the Scaling and Quota logic for the recipe tailoring feature. The current state includes:
- TailorRecipeCommand/Handler (Application)
- ScalingService (Domain) with full unit tests.
- QuotaService (Infrastructure) with atomic increment.
- TailoringService (Infrastructure Adapter) bridging Doctrine and Domain.

Please proceed with the next steps of the implementation plan:
1. Implement `AiReductionServiceInterface` and its implementation `AiReductionService` in `Infrastructure/Ai`. It should interface with OpenRouter.ai to reduce calories based on the `aggressiveness` and `keep_similar` parameters.
2. Update `TailoringService::tailor` to:
   - Implement the "Parse Gate": verify the active version has ≥ 80% parsed ingredients and ≤ 2 unknown units.
   - Orchestrate the two-step process: Scale first, then call AI Reduction.
   - Handle AI timeouts (fallback to returning the scaled version).
3. Create the `TailorRecipeController` to expose the POST `/api/recipes/{id}/tailor` endpoint, using `TailorRecipeCommandDto` and returning `TailorResultDto`.
4. Add functional API tests in `app/tests/Api` to verify the end-to-end flow (mocking the AI service).

Ensure all changes pass `make qa` and adhere to the existing Port-Adapter architecture.
```