1. Which exact **primary** and **secondary** job-to-be-done are we committing to for MVP (choose 1 + 1): **fast tailoring**, **stays similar**, **hit calorie target**, **reduce decision fatigue**, **high estimate accuracy**?

Recommendation: Commit to **Primary = fast tailoring** and **Secondary = stays similar** (based on your direction), and explicitly de-prioritize “precise calorie accuracy” in MVP messaging and acceptance criteria.

2. What is the finalized **optimization order** for Reduce Calories, and what are the hard-stop constraints (e.g., “never change primary protein unless user allows”)?

Recommendation: Encode this order in the PRD and tests: **Preserve cooking method + primary protein → preserve core flavor base → apply non-core swaps/portion rebalance within aggressiveness limits → chase calorie target last**.

3. What are the concrete **latency budgets** (P50/P95) per stage (parse, scale, rewrite+estimate) and the overall P95 (you referenced setting them, but no numbers yet)?

Recommendation: Define now: e.g., **Parse P95 ≤ 2s**, **Scale P95 ≤ 0.2s**, **Rewrite+estimate P95 ≤ 6s**, **End-to-end P95 ≤ 8s**, plus a hard timeout that triggers the fallback matrix.

4. What is the weekly (or daily) **usage cap** per user (tailors/week) and the **rate-limit behavior** when exceeded?

Recommendation: Pick a conservative cap for MVP (e.g., **50 tailors/week**) and implement: soft warning at 80%, hard block at 100% with “try again next week” + encourage saving/browsing cached recipes.

5. For “guided correction required,” what does “raw edit only” mean in practice: edit the whole recipe text, or edit **per-ingredient lines** (still raw text) before parsing?

Recommendation: Use **per-ingredient raw line editing** after initial extraction attempt: show the extracted lines (even if low confidence) and allow users to edit lines until minimum parse confidence threshold is met.

6. What are the **minimum parse acceptance criteria** to proceed (e.g., % of ingredients parsed, mandatory quantity/unit presence, confidence threshold)?

Recommendation: Define a strict gate: e.g., **≥80% of ingredient lines parsed with quantity OR a recognized “non-scalable” marker**, and **no more than N unknown units**; otherwise block tailoring and require edits.

7. What is the canonical handling of **“to taste / pinch / garnish / optional”** lines—do we keep them unscaled, drop them, or convert to estimated amounts?

Recommendation: Keep them as-is with a standardized label: **“(not scaled)”**, preserve raw_text, and exclude them from calorie math unless the model can confidently infer typical amounts.

8. With “no analytics stack,” what **minimal event data** are we still storing (schema), where is it stored, and what is the **retention policy**?

Recommendation: Store an internal append-only **events table** (no vendor) with retention (e.g., 30–90 days), capturing the MVP success metrics (profile complete, tailor success, save) plus latency and failure codes.

9. Without a formal analytics tool, who will **review success metrics** and how often (weekly cadence), and what is the **MVP launch success threshold**?

Recommendation: Define a lightweight process: weekly review using simple queries/exports; success thresholds like **profile_complete ≥ 60%**, **weekly tailoring users ≥ 40%**, **tailor success rate ≥ 90%**, **P95 under budget**.

10. What is the MVP’s **data model and storage plan** for recipes + versions (IDs, “latest pointer,” metadata fields, and deletion behavior), including how “Undo” is represented?

Recommendation: Implement **immutable versions** + a mutable **recipe_latest_version_id** pointer; “Overwrite” updates the pointer, “Save as new” creates a new recipe entity; “Undo” = revert pointer to prior version.

------------------------------------ Answers -----------------------------------------

1. Commit to **Primary = fast tailoring** and **Secondary = stays similar** (based on your direction), and explicitly de-prioritize “precise calorie accuracy” in MVP messaging and acceptance criteria.
2. Encode this order in the PRD and tests: **Preserve cooking method + primary protein → preserve core flavor base → apply non-core swaps/portion rebalance within aggressiveness limits → chase calorie target last**.
3. Define now: e.g., **Parse P95 ≤ 2s**, **Scale P95 ≤ 0.2s**, **Rewrite+estimate P95 ≤ 6s**, **End-to-end P95 ≤ 8s**, plus a hard timeout that triggers the fallback matrix.
4. Pick a conservative cap for MVP (e.g., **50 tailors/week**) and implement: soft warning at 80%, hard block at 100% with “try again next week” + encourage saving/browsing cached recipes.
5. Use **per-ingredient raw line editing** after initial extraction attempt: show the extracted lines (even if low confidence) and allow users to edit lines until minimum parse confidence threshold is met.
6. Define a strict gate: e.g., **≥80% of ingredient lines parsed with quantity OR a recognized “non-scalable” marker**, and **no more than N unknown units**; otherwise block tailoring and require edits.
7. Keep them as-is with a standardized label: **“(not scaled)”**, preserve raw_text, and exclude them from calorie math unless the model can confidently infer typical amounts.
8. Store an internal append-only **events table** (no vendor) with retention (e.g., 30–90 days), capturing the MVP success metrics (profile complete, tailor success, save) plus latency and failure codes.
9. Define a lightweight process: weekly review using simple queries/exports; success thresholds like **profile_complete ≥ 60%**, **weekly tailoring users ≥ 40%**, **tailor success rate ≥ 90%**, **P95 under budget**.
10.  Implement **immutable versions** + a mutable **recipe_latest_version_id** pointer; “Overwrite” updates the pointer, “Save as new” creates a new recipe entity; “Undo” = revert pointer to prior version.
