<conversation_summary>
<decisions>
1. Target users: individuals who want to lose weight.
2. MVP focuses on tailoring user-provided recipes (not generating from scratch).
3. Recipe data model: minimal structured schema with required fields: title, servings, ingredients, steps.
4. Recipe input UX: optimized for copy/paste using an input template with section headers (Ingredients/Steps), lightweight validation, and a one-click auto-format step before tailoring.
5. Tailoring modes: two primary modes—Reduce calories and Scale portions—with a simple “Mode + controls” UI.
6. Controls/defaults: servings is an explicit control (1–12); optional profile preference includes target calories per serving; defaults pulled from profile where available.
7. Tailoring order: sequential flow—Scale first, then optionally Reduce calories (explicit step 1 / step 2 UX).
8. Output format: standardized final recipe only (no comparison view): Title → Servings → Estimated calories/serving → Ingredients (with quantities) → Steps.
9. Units/localization: default to metric with locale detection; user-selectable Metric/US toggle stored in profile.
10. Calorie estimation: AI-based estimation with transparent “estimated calories” labeling; show total + per-serving plus a confidence indicator (low/med/high).
11. “Keep it similar” constraint: defined as preserving primary proteins + core flavor base + cooking method; prioritize changes in non-core items first.
12. Change aggressiveness: Low/Medium/High with explicit thresholds:
    - Low: ≤3 ingredient changes and ≤15% calorie reduction
    - Medium: ≤6 ingredient changes and ≤25% calorie reduction
    - High: ≤10 ingredient changes and ≤35% calorie reduction
13. Scaling behavior: deterministically scale ingredient quantities; only update critical step parameters when clear; otherwise keep steps minimal to avoid hallucinations.
14. Handling unrealistic targets: best-effort tailoring; if target is not met, include closest achievable estimate (as part of output metadata/labeling approach).
15. Persistence/versioning: tailored recipes are always saved as new records; include metadata (mode, target, aggressiveness, timestamp, model version). Provide “Save as new” vs “Overwrite existing” (must-have), but the chosen default is effectively “save as new always.”
16. Profile completion definition: profile is considered complete if either (a) at least one avoid item is provided OR (b) one weight-loss preference is set (e.g., target calories/serving).
17. Authentication: sign-in first in MVP; Google OAuth only.
18. Browsing: support Recent, Favorites, and basic search by title/keyword.
19. Analytics: instrument events from day one; no internal dashboard required in MVP.
20. Safety requirements: none for MVP (no special safety/trust constraints beyond labeling/UX choices already stated).
21. Performance/cost posture: set explicit latency/cost budgets (example given: P95 tailor < 8s, max operations/user/week) and implement failure handling; AI pipeline should be multi-step with caching.
22. Parsing requirement: require structured extraction into ingredient line-items (quantity + unit + item) before tailoring; if parsing fails, use guided user correction (do not send ambiguous text to the model).
23. Ingredient storage: store each ingredient as (raw_text, parsed_quantity, parsed_unit, parsed_item, confidence).
24. AI integration approach: multi-step pipeline with caching:
    (1) format/parse,
    (2) compute scaling deterministically,
    (3) AI rewrite + calorie estimate;
    cache parsed recipes for reuse.
</decisions>

<matched_recommendations>
1. Prioritize “paste recipe → tailor recipe” as the core MVP flow (confirmed: tailoring only).
2. Use a minimal structured recipe schema (title, servings, ingredients, steps) to support reliable transformations and browsing (confirmed).
3. Optimize input for copy/paste with formatting helpers and validation; include an auto-format step to improve AI parsing (confirmed).
4. Standardize a clean output contract for the tailored recipe; include estimated calories/serving in the output (confirmed).
5. Provide a simple mode-based UI (Reduce calories / Scale portions) with explicit controls (servings 1–12, optional target calories per serving) and sensible defaults from profile (confirmed).
6. Apply deterministic scaling first, then calorie reduction substitutions to maintain predictability (confirmed).
7. Add “Keep it similar” and “Max changes: low/medium/high” to control transformation aggressiveness and satisfaction (confirmed with explicit thresholds).
8. Use AI-based calorie estimation with transparent labeling and confidence indicator; defer full per-ingredient breakdown (confirmed).
9. Ensure persistence supports iteration: saving tailored recipe as a new record with metadata; include “Save as new vs overwrite” decision (confirmed; tailored saved as new with metadata, and save/overwrite control required).
10. Instrument analytics events and define success as “recipe_tailored_success” weekly, plus secondary metric for saves (confirmed); no dashboard required in MVP.
11. Use Google OAuth only for fastest onboarding; sign-in first (confirmed).
12. Multi-step AI pipeline with caching to reduce cost/latency and improve reliability under the performance budget (confirmed).
13. Require structured ingredient extraction and store parsed ingredient fields with confidence to support deterministic scaling (confirmed).
</matched_recommendations>

<prd_planning_summary>
a. Main functional requirements (MVP)
- Authentication & accounts:
  - Google OAuth-only login.
  - Sign-in required before use (MVP).
- User profile (weight-loss focused):
  - Store avoid list (free-form items to exclude or avoid).
  - Optional numeric preference: target calories per serving.
  - Store unit preference (Metric/US).
  - Profile completion definition: at least one avoid item OR one weight-loss preference set.
- Recipe management (CRUD + browsing):
  - Create recipes primarily via copy/paste into a template with Ingredients/Steps sections.
  - Validate presence of core sections; offer one-click auto-format.
  - Save/read/browse/delete recipes in text form with a minimal structured schema: title, servings, ingredients, steps.
  - Browsing includes: Recent, Favorites, and basic search by title/keyword.
  - Tailored recipes are stored as new records, tagged with metadata (mode, target, aggressiveness, timestamp, model version).
  - Provide “Save as new” vs “Overwrite existing” control (even if default behavior is always save-as-new for tailored outputs).
- AI tailoring:
  - Two modes:
    1) Scale portions (servings 1–12; deterministic scaling).
    2) Reduce calories (ingredient swaps + portion rebalancing).
  - Sequential flow: scale first, then optionally reduce calories (step 1/step 2 UI).
  - Output contract (final recipe only, no comparison):
    - Title → Servings → Estimated calories/serving (+ confidence low/med/high) → Ingredients (with quantities) → Steps.
  - Keep-it-similar toggle:
    - Preserve primary proteins + core flavor base + cooking method.
    - Prioritize changing non-core items first (oils, dairy, sweeteners).
  - Aggressiveness toggle:
    - Low: ≤3 ingredient changes and ≤15% calorie reduction.
    - Medium: ≤6 ingredient changes and ≤25% calorie reduction.
    - High: ≤10 ingredient changes and ≤35% calorie reduction.
  - Calorie estimation:
    - AI-based estimation; show total and per-serving + confidence indicator.
    - No detailed per-ingredient breakdown in MVP.
  - Handling unrealistic targets:
    - Best-effort tailoring; if target cannot be met, show closest estimated calories while still outputting the final recipe.

b. Key user stories and usage paths
- US1: Sign in and set preferences
  - As a new user, I sign in with Google and set my avoid list and/or target calories per serving (plus unit preference) so tailoring uses my defaults.
- US2: Add a recipe by copy/paste
  - As a user, I paste a recipe into the template; the system validates required sections and can auto-format to extract structured ingredients and steps.
- US3: Tailor recipe—scale portions
  - As a user, I set servings (1–12) and run “Scale portions” to deterministically update ingredient quantities (and only minimal step adjustments when clearly needed).
- US4: Tailor recipe—reduce calories
  - As a user, I run “Reduce calories” using my target calories per serving (optional) and aggressiveness/keep-similar toggles to get a lower-calorie version.
- US5: Save tailored output
  - As a user, I save the tailored recipe as a new recipe (with metadata) and optionally favorite it for later.
- US6: Browse and reuse
  - As a user, I browse recent/favorites and search by title/keyword, then re-run tailoring with different parameters using cached parsing.

c. Success criteria and measurement
- Success criteria from project brief:
  - 90% of users have dietary preferences filled out.
    - Interpretation for MVP: “profile complete” = (avoid list has ≥1 item) OR (target calories/serving is set).
    - Measurement: profile_completed event and profile field presence checks.
  - 75% of users generate one or more recipes per week.
    - Interpretation for MVP: weekly active generation = user triggers successful tailoring at least once per week.
    - Measurement: recipe_tailored_success event (primary), recipe_saved (secondary).
- Instrumentation (events):
  - profile_completed, recipe_created, recipe_parsed_success/failed (implied by parsing requirement), recipe_modified_ai, recipe_tailored_success, recipe_saved, recipe_viewed, favorite_toggled, auth_success/failure.
- Operational metrics (no dashboard required in MVP):
  - Monitor via logs/analytics export: tailor success rate, weekly tailors per user, profile completion rate, and latency (including P95 < target such as 8s).

d. Design/technical constraints impacting development
- Web-only with responsive layout.
- No URL importing, no images/multimedia, no sharing/social features.
- AI pipeline must support:
  - Structured extraction of ingredients with confidence.
  - Deterministic scaling before AI rewrite.
  - Caching parsed recipes to reduce cost/latency.
- Output must always be a clean final recipe (no diff/comparison UI).
</prd_planning_summary>

<unresolved_issues>
1. Exact definition of “Favorites” (binary favorite flag vs. pinned list) and whether it impacts success metrics or onboarding prompts.
2. Concrete AI cost/latency budgets and enforcement (e.g., max operations/user/week “X” is not yet specified; P95 target cited as an example but not finalized).
3. Specific failure handling UX flows are agreed conceptually (retry, format-first, save draft) but not fully specified (limits, messaging, and persistence rules for drafts).
4. Localization scope beyond units (language support, locale-specific ingredient naming) is not defined.
5. No dashboard is required, but the storage/retention requirements for analytics events (and chosen analytics stack) are not specified.
</unresolved_issues>
</conversation_summary>