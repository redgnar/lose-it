1. What is the exact “Tailor” interaction model—do users pick a mode (“Reduce calories” / “Scale portions”) and optionally set parameters, or should the system auto-apply defaults from profile and only ask when missing?
   Recommendation: Use a simple “Mode + controls” UI: Mode selector (Reduce calories / Scale portions) + optional inputs (target calories per serving, servings 1–12) with sane defaults from profile to keep the flow fast.

2. What is the required recipe input template/validation (minimum fields, formatting expectations), and what happens if the pasted recipe is messy or missing ingredients/steps?
   Recommendation: Provide an input template with section headers and lightweight validation (“missing ingredients/steps”) plus a one-click “auto-format” step before tailoring to reduce AI errors.

3. What should the tailored recipe output template look like (required fields + ordering), and should it include estimated calories/serving at the top?
   Recommendation: Standardize output as: Title → Servings → Estimated calories/serving → Ingredients (with quantities) → Steps; always return a clean final recipe without comparison, per your preference.

4. How should the app handle measurement units and localization (metric vs. US cups, language, decimal separators), given you’re targeting a web responsive audience?
   Recommendation: Default to metric + user locale detection, but include a simple toggle (Metric/US) and store user preference in profile to avoid repeated conversions.

5. What are the rules for “Reduce calories” substitutions (e.g., prioritize lower-fat swaps, reduce added sugar, cooking method changes), and are there any forbidden substitutions (e.g., don’t replace meat with tofu)?
   Recommendation: Encode a ranked substitution strategy per category (dairy, oils, sugars, sauces) and allow “Keep it similar” to constrain substitutions to same-category swaps.

6. What does “Max changes: low/medium/high” mean operationally (max number of ingredient changes, max % calorie reduction, max step changes)?
   Recommendation: Define explicit thresholds, e.g., Low: ≤3 ingredient changes + ≤15% calorie reduction, Medium: ≤6 + ≤25%, High: ≤10 + ≤35%, so behavior is predictable and testable.

7. When portion scaling is applied, should ingredient quantities be strictly scaled, and should steps be updated (e.g., pan size, bake time), or left mostly unchanged?
   Recommendation: Strictly scale ingredient quantities and update only critical step parameters when clear (cook time ranges, container size hints), otherwise keep steps minimal to avoid hallucinated instructions.

8. What is the expected behavior when the user sets “target calories per serving” that seems unrealistic for the recipe (e.g., 200 kcal for lasagna)—should the AI refuse, warn, or do its best?
   Recommendation: Do best-effort tailoring and include a brief note like “Could not reach target; closest estimate is X kcal” while still outputting the final recipe.

9. What core recipe management actions must exist in MVP besides CRUD (e.g., duplicate recipe, save tailored as new vs overwrite, version history)?
   Recommendation: Include “Save as new” vs “Overwrite existing” as a must-have to prevent accidental loss, and defer version history to post-MVP.

10. What are your MVP non-functional requirements: performance targets (tailor response time), AI cost ceiling per user/week, and reliability/fallback UX when AI fails?
    Recommendation: Set explicit budgets (e.g., P95 tailor < 8s, max X tailor operations/user/week) and implement graceful failure states (retry, “format recipe first”, and save draft input) to protect retention and the weekly success metric.

------------------------------------ Answers -----------------------------------------

1. Use a simple “Mode + controls” UI: Mode selector (Reduce calories / Scale portions) + optional inputs (target calories per serving, servings 1–12) with sane defaults from profile to keep the flow fast.
2. Provide an input template with section headers and lightweight validation (“missing ingredients/steps”) plus a one-click “auto-format” step before tailoring to reduce AI errors.
3. Standardize output as: Title → Servings → Estimated calories/serving → Ingredients (with quantities) → Steps; always return a clean final recipe without comparison, per your preference.
4. Default to metric + user locale detection, but include a simple toggle (Metric/US) and store user preference in profile to avoid repeated conversions.
5. Encode a ranked substitution strategy per category (dairy, oils, sugars, sauces) and allow “Keep it similar” to constrain substitutions to same-category swaps.
6. Define explicit thresholds, e.g., Low: ≤3 ingredient changes + ≤15% calorie reduction, Medium: ≤6 + ≤25%, High: ≤10 + ≤35%, so behavior is predictable and testable.
7. Strictly scale ingredient quantities and update only critical step parameters when clear (cook time ranges, container size hints), otherwise keep steps minimal to avoid hallucinated instructions.
8. Do best-effort tailoring and include a brief note like “Could not reach target; closest estimate is X kcal” while still outputting the final recipe.
9. Include “Save as new” vs “Overwrite existing” as a must-have to prevent accidental loss, and defer version history to post-MVP.
10. Set explicit budgets (e.g., P95 tailor < 8s, max X tailor operations/user/week) and implement graceful failure states (retry, “format recipe first”, and save draft input) to protect retention and the weekly success metric.