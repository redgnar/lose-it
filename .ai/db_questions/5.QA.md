<questions>
1. How should the `RecipeVersion` steps be structured within the `JSON` column to ensure future-proofing and compatibility with MariaDB's `JSON_VALID()`?

Recommendation: Use an array of objects format, e.g., `[{"text": "...", "order": 1, "metadata": {}}]`. This allows for the addition of step-specific data (like timers or tool requirements) without breaking existing parsing logic, while `JSON_VALID()` ensures structural integrity at the database level.

2. Should the `avoid_list` many-to-many relationship be linked to a global `IngredientRegistry` or a per-user custom ingredient list?

Recommendation: Link the many-to-many relationship to a global `IngredientRegistry`. This enables shared normalization across all users and allows the system to efficiently suggest recipes that do not contain ingredients on a user's `avoid_list` using standard SQL JOINs.

3. How should the synchronization between the `Recipe` entity and the current `RecipeVersion` be managed, given that `Recipe` now contains a copy of all version fields?

Recommendation: Use Application-layer logic (Symfony listeners or services) to update the `Recipe` fields whenever a new `RecipeVersion` is promoted to "current". This redundancy improves read performance for the most frequent "view recipe" use case by avoiding a JOIN with the version table.

4. How should the denormalized `search_text` column for `FULLTEXT` indexing be updated to include both `Recipe` metadata and ingredient names?

Recommendation: Implement a service that concatenates the title, description, and the names of all associated ingredients into the `search_text` column. Update this column whenever the `Recipe` or its "current" ingredients change to ensure search results remain accurate and performant.

5. Should the `DECIMAL` precision for `RecipeIngredient` quantities be standardized across the database?

Recommendation: Yes, use `DECIMAL(12, 4)` for all ingredient quantities. This provides enough precision for small units (like "grams of saffron") and large quantities (like "liters of water"), ensuring that math-heavy operations like deterministic scaling remain accurate.

6. How should the `substitutions` table be structured to link original ingredients to their AI-proposed alternatives across versions?

Recommendation: Include `original_ingredient_id`, `substituted_ingredient_id`, and `recipe_version_id` in the `substitutions` table. This structure allows the system to "remember" successful swaps and provides data for analytics on user-accepted dietary adjustments.

7. How should the MariaDB Table Partitioning for the `Events` table be configured for optimal 90-day retention?

Recommendation: Use `PARTITION BY RANGE (TO_DAYS(created_at))` with monthly partitions. This allows a Symfony console command to drop the oldest partition with minimal I/O overhead compared to a standard `DELETE` query, which can lock the table and bloat the undo log.

8. How should the `is_verified` flag in the `IngredientRegistry` be used during the recipe parsing and scaling process?

Recommendation: Use verified ingredients from the registry as the primary source for nutritional data. If a user adds an unverified ingredient (`is_verified = 0`), flag the recipe's calorie status as `Unavailable` until the ingredient is matched or manually verified by an admin.

9. What is the most reliable way to trigger the cleanup of expired `draft_content` and `pending_recipe` records?

Recommendation: Schedule a Symfony command via a system-level cron job to run every hour. The command should execute `DELETE FROM pending_recipes WHERE expires_at < NOW()` to ensure that abandoned parses do not consume storage or clutter the UI.

10. How can the atomic update strategy for `TailoringQuota` be optimized to prevent race conditions during peak AI usage?

Recommendation: Use a single SQL statement: `UPDATE tailoring_quota SET count = IF(last_reset < ?, 1, count + 1), last_reset = IF(last_reset < ?, ?, last_reset) WHERE user_id = ? AND (count < 50 OR last_reset < ?)`. This ensures that the quota check and increment (or reset) happen in a single transaction.
</questions>

<answers>
1. Use an array of objects format, e.g., `[{"text": "...", "order": 1, "metadata": {}}]`. This allows for the addition of step-specific data (like timers or tool requirements) without breaking existing parsing logic, while `JSON_VALID()` ensures structural integrity at the database level.
2. Link the many-to-many relationship to a global `IngredientRegistry`. This enables shared normalization across all users and allows the system to efficiently suggest recipes that do not contain ingredients on a user's `avoid_list` using standard SQL JOINs.
3. Use Application-layer logic (Symfony listeners or services) to update the `Recipe` fields whenever a new `RecipeVersion` is promoted to "current". This redundancy improves read performance for the most frequent "view recipe" use case by avoiding a JOIN with the version table.
4. Implement a service that concatenates the title, description, and the names of all associated ingredients into the `search_text` column. Update this column whenever the `Recipe` or its "current" ingredients change to ensure search results remain accurate and performant.
5. Yes, use `DECIMAL(12, 4)` for all ingredient quantities. This provides enough precision for small units (like "grams of saffron") and large quantities (like "liters of water"), ensuring that math-heavy operations like deterministic scaling remain accurate.
6. Include `original_ingredient_id`, `substituted_ingredient_id`, and `recipe_version_id` in the `substitutions` table. This structure allows the system to "remember" successful swaps and provides data for analytics on user-accepted dietary adjustments.
7. Use `PARTITION BY RANGE (TO_DAYS(created_at))` with monthly partitions. This allows a Symfony console command to drop the oldest partition with minimal I/O overhead compared to a standard `DELETE` query, which can lock the table and bloat the undo log.
8. Use verified ingredients from the registry as the primary source for nutritional data. If a user adds an unverified ingredient (`is_verified = 0`), flag the recipe's calorie status as `Unavailable` until the ingredient is matched or manually verified by an admin.
9. Schedule a Symfony command via a system-level cron job to run every hour. The command should execute `DELETE FROM pending_recipes WHERE expires_at < NOW()` to ensure that abandoned parses do not consume storage or clutter the UI.
10. Use a single SQL statement: `UPDATE tailoring_quota SET count = IF(last_reset < ?, 1, count + 1), last_reset = IF(last_reset < ?, ?, last_reset) WHERE user_id = ? AND (count < 50 OR last_reset < ?)`. This ensures that the quota check and increment (or reset) happen in a single transaction.

</answers>