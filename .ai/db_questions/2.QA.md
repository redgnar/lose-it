<questions>
1. Since MariaDB is chosen, how should the `avoid_list` in `UserPreference` be stored for efficient "avoidance" checking by the AI and application?

Recommendation: Use a standard many-to-many relationship with an `ingredients_registry` or a `LONGTEXT` column with JSON validation `CHECK (JSON_VALID(avoid_list))` if the list is small. MariaDB's `JSON_CONTAINS` can then be used to check for exclusions without needing a complex join for every single ingredient.

2. Given the "Scale first, then Reduce Calories" sequential flow, should the database store intermediate "Scaled-only" versions?

Recommendation: To optimize for the 2-second Scaling P95, the system should save the "Scaled-only" version immediately as a `RecipeVersion`. This provides a fallback if the AI Calorie Reduction (which has an 8-second budget) fails or times out, ensuring the user always sees the scaled result as required by PRD 3.6.

3. How should "Confidence Labeling" (Low, Medium, High) be persisted and calculated?

Recommendation: Store a `confidence_score` (0.0 to 1.0) and a `confidence_label` (Enum: Low, Medium, High) on the `RecipeVersion` entity. The score should be calculated at the application level during parsing/tailoring based on the percentage of successfully parsed ingredients and AI response metadata.

4. How will the search functionality be implemented in MariaDB without PostgreSQL's GIN/tsvector?

Recommendation: Use MariaDB's `FULLTEXT` indexing on the `title` of the `Recipe` and the `name` of ingredients in the `RecipeVersion`. This allows for efficient `MATCH() AGAINST()` queries for searching recipes by title or keyword as described in US-012.

5. How should the "Metric vs US" toggle be handled at the database level to ensure consistency?

Recommendation: Store all quantities in the database using a base "internal" unit (e.g., grams or milliliters) or store the original value + original unit + unit system flag. The latter is safer for recipes where rounding errors from conversion might affect "keep-it-similar" constraints.

6. Should the `tailoring_quota` reset be handled by a scheduled job or lazily upon the user's first request of the week?

Recommendation: Reset the quota lazily. When a user attempts tailoring, check if `last_reset_date` is more than 7 days ago. If so, reset `current_week_count` to 0 and update `last_reset_date`. This avoids the need for a cron job managing thousands of users simultaneously.

7. How should we handle the "Aggressiveness Thresholds" in the schema to ensure the AI stays within limits?

Recommendation: Store the `aggressiveness_level` on the `RecipeVersion` and log the number of ingredient changes made by the AI in a `metadata` JSON column. This allows for auditing and ensures that the "Low" (3 changes) or "High" (10 changes) constraints are being tracked and respected.

8. For the "Undo" functionality, how long should the "previous version" be preserved if the user does multiple overwrites?

Recommendation: Since all versions are immutable and associated with the `Recipe`, all previous versions should be preserved by default unless explicitly deleted. The "Undo" action simply updates the `current_version_id` back to the `parent_version_id`. This aligns with the "cascading deletion" rule—data is only lost when the recipe or account is deleted.

9. How should the AI "substitutions" be tracked for the "Ingredients and Steps" update (US-006 & US-007)?

Recommendation: Use a `substitutions` table or JSON log linked to the `RecipeVersion` that maps `original_ingredient_id` to `new_ingredient_id`. This allows the UI to highlight exactly what changed (e.g., "Swapped Butter for Apple Sauce") for the user.

10. Since we are enforcing security at the application layer with Doctrine Filters, how do we handle shared resources like the "Unit Registry"?

Recommendation: The `UnitRegistry` and `IngredientRegistry` (if applicable) should be "Global" entities that are excluded from the `UserAwareFilter`. This ensures all users can access the same normalization data while their personal recipes remain strictly isolated by the filter.
</questions>

<answers>
1. Use a standard many-to-many relationship with an `ingredients_registry` or a `LONGTEXT` column with JSON validation `CHECK (JSON_VALID(avoid_list))` if the list is small. MariaDB's `JSON_CONTAINS` can then be used to check for exclusions without needing a complex join for every single ingredient.
2. To optimize for the 2-second Scaling P95, the system should save the "Scaled-only" version immediately as a `RecipeVersion`. This provides a fallback if the AI Calorie Reduction (which has an 8-second budget) fails or times out, ensuring the user always sees the scaled result as required by PRD 3.6.
3. Store a `confidence_score` (0.0 to 1.0) and a `confidence_label` (Enum: Low, Medium, High) on the `RecipeVersion` entity. The score should be calculated at the application level during parsing/tailoring based on the percentage of successfully parsed ingredients and AI response metadata.
4. Use MariaDB's `FULLTEXT` indexing on the `title` of the `Recipe` and the `name` of ingredients in the `RecipeVersion`. This allows for efficient `MATCH() AGAINST()` queries for searching recipes by title or keyword as described in US-012.
5. Store all quantities in the database using a base "internal" unit (e.g., grams or milliliters) or store the original value + original unit + unit system flag. The latter is safer for recipes where rounding errors from conversion might affect "keep-it-similar" constraints.
6. Reset the quota lazily. When a user attempts tailoring, check if `last_reset_date` is more than 7 days ago. If so, reset `current_week_count` to 0 and update `last_reset_date`. This avoids the need for a cron job managing thousands of users simultaneously.
7. Store the `aggressiveness_level` on the `RecipeVersion` and log the number of ingredient changes made by the AI in a `metadata` JSON column. This allows for auditing and ensures that the "Low" (3 changes) or "High" (10 changes) constraints are being tracked and respected.
8. Since all versions are immutable and associated with the `Recipe`, all previous versions should be preserved by default unless explicitly deleted. The "Undo" action simply updates the `current_version_id` back to the `parent_version_id`. This aligns with the "cascading deletion" rule—data is only lost when the recipe or account is deleted.
9. Use a `substitutions` table or JSON log linked to the `RecipeVersion` that maps `original_ingredient_id` to `new_ingredient_id`. This allows the UI to highlight exactly what changed (e.g., "Swapped Butter for Apple Sauce") for the user.
10. The `UnitRegistry` and `IngredientRegistry` (if applicable) should be "Global" entities that are excluded from the `UserAwareFilter`. This ensures all users can access the same normalization data while their personal recipes remain strictly isolated by the filter.
</answers>