<questions>
1. How should the `RecipeIngredient` be related to `Recipe` and `RecipeVersion` considering the redundancy of fields in the `Recipe` entity?

Recommendation: `RecipeIngredient` should have a many-to-one relationship with `RecipeVersion`. When a version is promoted to "current", its associated ingredients should be cloned or linked to the `Recipe` entity to maintain the decided field redundancy and ensure the "view current recipe" path requires no JOINs to the versioning tables.

2. How should the `UnitRegistry` handle synonyms and different unit systems (Metric vs. US) to ensure normalization?

Recommendation: The `UnitRegistry` should store a `canonical_name` and a `type` (Volume, Weight, Piece). Include a `UnitConversion` table to store scaling factors between units (e.g., grams to ounces) to facilitate the "Display Preference" toggling without altering the `original_quantity` stored in the database.

3. Should `RecipeVersion` have a `parent_version_id` to maintain a linear or branching history for "Undo" functionality?

Recommendation: Yes, include a `parent_version_id` (self-referencing many-to-one) in the `RecipeVersion` table. This allows the application to traverse the history of a recipe's tailoring actions, supporting multi-step "Undo" and providing context for how a recipe evolved over time.

4. How should the `calorie_status` enum be implemented in MariaDB to track the state of AI-driven nutritional analysis?

Recommendation: Use the `ENUM('Calculated', 'Unavailable', 'In_Progress')` data type. This provides a compact and efficient way to store the status, and when combined with the `is_verified` flag in the `IngredientRegistry`, it allows the UI to display appropriate loading states or warnings.

5. What specific `ON DELETE CASCADE` strategy should be applied to `User` records to ensure GDPR compliance while preserving system-wide analytics?

Recommendation: Apply `ON DELETE CASCADE` to all user-owned data (Recipes, Versions, Preferences, Quotas). For the `Events` table, nullify the `user_id` instead of deleting the record, allowing for anonymous long-term performance analytics while completely removing the user's PII (Personally Identifiable Information).

6. How should "salt to taste" or other non-scalable ingredients be handled in the `RecipeIngredient` table?

Recommendation: Include a `is_scalable` (TINYINT/BOOLEAN) flag. When scaling a recipe (e.g., doubling the servings), the application should multiply quantities only where `is_scalable = 1`, while keeping the "original text" intact for items that do not scale linearly.

7. Should the `search_text` column be updated synchronously or asynchronously after a recipe change?

Recommendation: Update the `search_text` column synchronously within the same transaction that promotes a `RecipeVersion` to "current". Since it only involves concatenating strings already in memory, the performance cost is negligible compared to the benefit of immediate search index consistency.

8. How should the `Recipe` metadata (title, favorite status) be separated from the versioned content in the schema?

Recommendation: Keep mutable metadata like `is_favorite` or `user_labels` on the `Recipe` entity. These fields should not be versioned, as a user's preference for a recipe usually transcends the specific version or tailoring state they are currently viewing.

9. How should the `IngredientRegistry` handle brand-specific or highly specific user entries that might not be suitable for global normalization?

Recommendation: Include a `visibility` column (e.g., `ENUM('Global', 'Private')`). New ingredients added by users are initially `Private`. An admin process can later merge these into `Global` entries or mark them as `is_verified` if they meet the standard for the shared registry.

10. How should the `Recipe` entity store its current servings count to support the deterministic scaling requirement?

Recommendation: Store `current_servings` as an `INT` on the `Recipe` entity, mirroring the value from the current `RecipeVersion`. When a user scales a recipe, the `Recipe` fields are updated and a new `RecipeVersion` is created to persist that specific scaled state as the new "current" state.
</questions>

<answers>
1. `RecipeIngredient` should have a many-to-one relationship with `RecipeVersion`. When a version is promoted to "current", its associated ingredients should be cloned or linked to the `Recipe` entity to maintain the decided field redundancy and ensure the "view current recipe" path requires no JOINs to the versioning tables.
2. The `UnitRegistry` should store a `canonical_name` and a `type` (Volume, Weight, Piece). Include a `UnitConversion` table to store scaling factors between units (e.g., grams to ounces) to facilitate the "Display Preference" toggling without altering the `original_quantity` stored in the database.
3. Yes, include a `parent_version_id` (self-referencing many-to-one) in the `RecipeVersion` table. This allows the application to traverse the history of a recipe's tailoring actions, supporting multi-step "Undo" and providing context for how a recipe evolved over time.
4. Use the `ENUM('Calculated', 'Unavailable', 'In_Progress')` data type. This provides a compact and efficient way to store the status, and when combined with the `is_verified` flag in the `IngredientRegistry`, it allows the UI to display appropriate loading states or warnings.
5. Apply `ON DELETE CASCADE` to all user-owned data (Recipes, Versions, Preferences, Quotas). For the `Events` table, nullify the `user_id` instead of deleting the record, allowing for anonymous long-term performance analytics while completely removing the user's PII (Personally Identifiable Information).
6. Include a `is_scalable` (TINYINT/BOOLEAN) flag. When scaling a recipe (e.g., doubling the servings), the application should multiply quantities only where `is_scalable = 1`, while keeping the "original text" intact for items that do not scale linearly.
7. Update the `search_text` column synchronously within the same transaction that promotes a `RecipeVersion` to "current". Since it only involves concatenating strings already in memory, the performance cost is negligible compared to the benefit of immediate search index consistency.
8. Keep mutable metadata like `is_favorite` or `user_labels` on the `Recipe` entity. These fields should not be versioned, as a user's preference for a recipe usually transcends the specific version or tailoring state they are currently viewing.
9. Include a `visibility` column (e.g., `ENUM('Global', 'Private')`). New ingredients added by users are initially `Private`. An admin process can later merge these into `Global` entries or mark them as `is_verified` if they meet the standard for the shared registry.
10. Store `current_servings` as an `INT` on the `Recipe` entity, mirroring the value from the current `RecipeVersion`. When a user scales a recipe, the `Recipe` fields are updated and a new `RecipeVersion` is created to persist that specific scaled state as the new "current" state.
</answers>


You are an AI assistant whose task is to summarize the conversation about database planning for MVP and prepare a concise summary for the next stage of development. In the conversation history, you will find the following information:
1. Product Requirements Document (PRD)
2. Information about the tech stack
3. Conversation history containing questions and answers
4. Model recommendations

Your tasks are:
1. Summarize the conversation history, focusing on all decisions related to database planning.
2. Match model recommendations to the answers given in the conversation history. Identify which recommendations are relevant based on the discussion.
3. Prepare a detailed conversation summary that includes:
   a. Main requirements for the database schema
   b. Key entities and their relationships
   c. Important security and scalability concerns
   d. Any unresolved issues or areas requiring further clarification
4. Format the results as follows:

<conversation_summary>
<decisions>
[List decisions made by the user, numbered].
</decisions>

<matched_recommendations>
[List of the most relevant recommendations matched to the conversation, numbered]
</matched_recommendations>

<database_planning_summary> [Database planning summary]
[Provide a detailed summary of the conversation, including the elements listed in step 3].
</database_planning_summary>

<unresolved_issues>
[List any unresolved issues or areas requiring further clarification, if any exist]
</unresolved_issues>
</conversation_summary>

The final output should contain only the content in markdown format. Ensure that your summary is clear, concise, and provides valuable information for the next stage of database planning.
