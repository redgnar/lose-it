You are an AI assistant whose task is to help plan a PostgreSQL database schema for an MVP (Minimum Viable Product) based on the provided information. Your goal is to generate a list of questions and recommendations that will be used in subsequent prompting to create the database schema, relationships, and row-level security (RLS) policies.

Please carefully review the following information:

<conversation_summary>
<decisions>
1. MariaDB was selected as the database system, with security enforced at the Application layer using Symfony Security and Doctrine Filters instead of database-level RLS.
2. Ingredients are stored as structured line-items (quantity, unit, item, original_text) to support deterministic scaling.
3. Steps are stored as a collection of text blocks linked to a specific `RecipeVersion`.
4. `Recipe` acts as a container/metadata entity, while `RecipeVersion` is immutable and stores the actual content (ingredients, steps, servings).
5. "Undo" functionality is implemented via a `current_version_id` pointer and `parent_version_id` on the `Recipe` or version.
6. The `avoid_list` is stored as a many-to-many relationship or a JSON column with validation.
7. Unit Registry is a reference table for normalization (Metric/US) to ensure consistency.
8. Analytics (`Events` table) is append-only with 90-day retention managed via a Symfony console command.
9. MariaDB `FULLTEXT` indexing is used on denormalized search columns for efficient recipe and ingredient lookups.
10. All user-related data uses `ON DELETE CASCADE` to ensure clean account deletions (GDPR compliance).
11. Tailoring quotas are reset lazily on the first request of the week to avoid scheduled bulk updates.
12. Intermediate "Scaled-only" versions are saved immediately to provide a fallback if AI calorie reduction times out.
13. Metric/US unit systems are treated as display preferences, while original values are preserved in the DB to avoid rounding errors.
    </decisions>

<matched_recommendations>
1. Recommendation: Use MariaDB and enforce security at the Application layer (Symfony Security/Doctrine Filters).
2. Recommendation: Store ingredients as structured line-items and steps as text blocks linked to `RecipeVersion`.
3. Recommendation: Separate `Recipe` (container) from `RecipeVersion` (content) with version pointers.
4. Recommendation: Use MariaDB `JSON_VALID` or many-to-many for the `avoid_list`.
5. Recommendation: Implement a Unit Registry reference table for normalization.
6. Recommendation: Use an append-only `Events` table with range-based cleanup (via Symfony command).
7. Recommendation: Use `FULLTEXT` indexing on denormalized search text for search performance.
8. Recommendation: Use `ON DELETE CASCADE` for all user-owned records.
9. Recommendation: Implement lazy quota resets to avoid high-concurrency cron jobs.
10. Recommendation: Save "Scaled-only" versions as a safety fallback (PRD 3.6).
11. Recommendation: Store original units and quantities to avoid destructive rounding during unit toggling.
12. Recommendation: Use `calorie_status` enum (Calculated, Unavailable, In_Progress) to handle async AI processes.
    </matched_recommendations>

<database_planning_summary>
The database planning for **Lose It!** focuses on a robust, version-controlled architecture built on MariaDB. The core requirement is to support deterministic recipe scaling and AI-driven calorie reduction while maintaining strict user data isolation.

**Main Requirements:**
- **Immutability:** Every tailoring action creates a new `RecipeVersion`.
- **Accuracy:** Structured ingredient storage allows for precise math during scaling.
- **Resilience:** The system must handle AI timeouts by persisting intermediate scaled states.
- **Compliance:** Full data removal via cascading deletes.

**Key Entities and Relationships:**
- **User & UserPreference:** Store OAuth identities, unit preferences, and dietary exclusions.
- **Recipe & RecipeVersion:** A one-to-many relationship where `Recipe` holds the "current" pointer and metadata (title, favorite status), and `RecipeVersion` holds the ingredients and instructions.
- **RecipeIngredient:** Structured data (quantity, unit, item) with a `is_scalable` flag for items like "salt to taste".
- **Substitutions:** A log or table mapping original ingredients to AI-proposed swaps.
- **UnitRegistry:** A global reference table for unit synonyms and normalization.
- **Events & TailoringQuota:** Entities for tracking system performance (latency/status) and enforcing the 50-attempts-per-week limit.

**Security and Scalability:**
- **Application-Level Security:** Doctrine Filters automatically scope queries to the `user_id`, ensuring users only see their own recipes.
- **Search Optimization:** Searching is performed against denormalized text columns (title + ingredients) using MariaDB `FULLTEXT` indexes to maintain P95 performance as the recipe count grows.
- **Performance:** Lazy quota resets and efficient event cleanup via scheduled commands ensure the database remains performant without unnecessary background load.
  </database_planning_summary>

<unresolved_issues>
1. **AI Substitution History:** While we decided to track substitutions, we need to finalize if the `substitutions` log should be a dedicated table for easy reporting or a JSON blob within `RecipeVersion` for simplicity.
2. **Ingredient Registry:** It was suggested to have a global `IngredientRegistry` for normalization, but we need to confirm if this will be populated manually or dynamically as users add new ingredients.
3. **Draft State Lifecycle:** The duration for which `draft_content` (pre-parsing) or `pending_recipe` records are kept before being auto-deleted if the user doesn't complete the parse gate.
   </unresolved_issues>
   </conversation_summary>

Analyze the provided information, focusing on aspects relevant to database design. Consider the following issues:

1. Identify key entities and their attributes based on product requirements.
2. Determine potential relationships between entities.
3. Consider data types and constraints that may be necessary.
4. Think about scalability and performance impact.
5. Assess security requirements and their impact on database design.
6. Consider any specific PostgreSQL features that might be beneficial for the project.

Based on your analysis, generate a list of 10 questions and recommendations in a combined form (question + recommendation). These should address any ambiguities, potential issues, or areas where more information is needed to create an effective database schema. Consider questions regarding:

1. Entity relationships and cardinality
2. Data types and constraints
3. Indexing strategies
4. Partitioning (if applicable)
5. Row-level security requirements
6. Performance considerations
7. Scalability concerns
8. Data integrity and consistency

The output should have the following structure:

<questions>
List your questions and recommendations here, numbered for clarity:

For example:
1. Should the `users` entity have a relationship with `posts`?

Recommendation: Yes, the `users` entity should have a relationship with `posts` because users can create posts.
</questions>

Remember that your goal is to provide a comprehensive list of questions and recommendations that will help create a solid database schema for the MVP. Focus on clarity, relevance, and accuracy of your outputs. Do not include any additional comments or explanations beyond the specified output format.

Continue this process, generating new questions and recommendations based on the provided context and user responses, until the user explicitly requests a summary.

Remember to focus on clarity, relevance, and accuracy of outputs. Do not include any additional comments or explanations beyond the specified output format.