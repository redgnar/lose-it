<questions>
1. The technical stack mentions MariaDB, but the task description asks for PostgreSQL and Row-Level Security (RLS) policies. Which database system should be used for the implementation?

Recommendation: Since MariaDB does not natively support RLS in the same way PostgreSQL does, the schema should be designed for PostgreSQL if RLS is a hard requirement. If MariaDB is preferred, security must be enforced at the Application layer (Symfony Security/Doctrine Filters) rather than the Database layer.

2. How should the `ingredients` and `steps` be stored to support both deterministic scaling and AI-driven calorie reduction while maintaining versioning?

Recommendation: Store ingredients as structured line-items (quantity, unit, item, original_text) and steps as a collection of text blocks linked to a specific `RecipeVersion`. This allows for precise scaling of quantities and easy replacement of ingredients by the AI without losing the original context.

3. Should `RecipeVersion` be a separate entity from `Recipe`, and how should the "undo" functionality be implemented?

Recommendation: Yes, a `Recipe` should act as a container, while `RecipeVersion` stores the actual content (ingredients, steps, servings). The `Recipe` should have a `current_version_id` pointer. For the undo functionality, a `parent_version_id` or a simple "previous_version_id" on the `Recipe` can allow quick restoration of the prior state.

4. How should the `User` avoid list and target calorie preferences be stored for optimal AI matching and validation?

Recommendation: Store the avoid list as a separate `UserPreference` table or a JSONB column (if using PostgreSQL) to allow for easy lookups. This ensures that when the AI proposes substitutions, the system can efficiently cross-reference them against the user's specific exclusions.

5. What is the best way to handle the "Unit Registry" (unit normalization and synonyms) within the database?

Recommendation: Store the Unit Registry as a reference table with `name`, `abbreviation`, and `system` (Metric/US). This allows the application to perform joins during parsing and ensures consistency across all recipes, rather than relying solely on a versioned JSON file which might be harder to query.

6. How should the `Events` table for analytics be structured to meet the 30â€“90 day retention and P95 latency reporting requirements?

Recommendation: Use an append-only table with columns for `user_id`, `action_type`, `status_code`, `latency_ms`, and `created_at`. If using PostgreSQL, consider partitioning by range (e.g., monthly) to make the data retention cleanup (dropping old partitions) efficient without impacting performance.

7. How should "Favorites" and "Search" be indexed to maintain performance as the number of recipes grows?

Recommendation: Create a composite index on `(user_id, is_favorite)` for the dashboard. For search, implement a GIN index on a `tsvector` column (PostgreSQL Full-Text Search) covering recipe titles and ingredient items to ensure fast keyword lookups across large sets of user data.

8. Given the "Account Deletion" requirement (cascading deletion), should we rely on database-level `ON DELETE CASCADE` or application-level deletion?

Recommendation: Use database-level `ON DELETE CASCADE` constraints for all user-related data (Profiles, Recipes, Versions, Events). This ensures data integrity and regulatory compliance (GDPR) by guaranteeing that no orphaned records remain after a user deletes their account.

9. How should the "Weekly Tailoring Limit" (50 attempts per week) be tracked efficiently?

Recommendation: Instead of counting rows in the `Events` table on every request, maintain a `tailoring_quota` table or cache that stores `user_id`, `current_week_count`, and `last_reset_date`. This avoids expensive aggregation queries on the analytics table during the critical path of a recipe tailoring request.

10. For the "Guided Parse Correction" UI, do we need to store partially parsed or "failed" ingredients?

Recommendation: Yes, ingredients should have a `is_parsed` boolean flag and a `raw_text` field. This allows the system to store the recipe even if the parse gate isn't met, enabling the user to return later and correct the specific lines that failed validation.
</questions>

<answers>
1. MariaDB is preferred, security must be enforced at the Application layer (Symfony Security/Doctrine Filters) rather than the Database layer.
2. Store ingredients as structured line-items (quantity, unit, item, original_text) and steps as a collection of text blocks linked to a specific `RecipeVersion`. This allows for precise scaling of quantities and easy replacement of ingredients by the AI without losing the original context.
3. Yes, a `Recipe` should act as a container, while `RecipeVersion` stores the actual content (ingredients, steps, servings). The `Recipe` should have a `current_version_id` pointer. For the undo functionality, a `parent_version_id` or a simple "previous_version_id" on the `Recipe` can allow quick restoration of the prior state.
4. Store the avoid list as a separate `UserPreference` table or a JSONB column (if using PostgreSQL) to allow for easy lookups. This ensures that when the AI proposes substitutions, the system can efficiently cross-reference them against the user's specific exclusions.
5. Store the Unit Registry as a reference table with `name`, `abbreviation`, and `system` (Metric/US). This allows the application to perform joins during parsing and ensures consistency across all recipes, rather than relying solely on a versioned JSON file which might be harder to query.
6. Use an append-only table with columns for `user_id`, `action_type`, `status_code`, `latency_ms`, and `created_at`. If using PostgreSQL, consider partitioning by range (e.g., monthly) to make the data retention cleanup (dropping old partitions) efficient without impacting performance.
7. Create a composite index on `(user_id, is_favorite)` for the dashboard. For search, implement a GIN index on a `tsvector` column (PostgreSQL Full-Text Search) covering recipe titles and ingredient items to ensure fast keyword lookups across large sets of user data.
8. Use database-level `ON DELETE CASCADE` constraints for all user-related data (Profiles, Recipes, Versions, Events). This ensures data integrity and regulatory compliance (GDPR) by guaranteeing that no orphaned records remain after a user deletes their account.
9. Instead of counting rows in the `Events` table on every request, maintain a `tailoring_quota` table or cache that stores `user_id`, `current_week_count`, and `last_reset_date`. This avoids expensive aggregation queries on the analytics table during the critical path of a recipe tailoring request.
10. Yes, ingredients should have a `is_parsed` boolean flag and a `raw_text` field. This allows the system to store the recipe even if the parse gate isn't met, enabling the user to return later and correct the specific lines that failed validation.
</answers>