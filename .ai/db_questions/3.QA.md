<questions>
1. How should the "Auto-format" utility (PRD 3.3) interact with the database before parsing?

Recommendation: The auto-formatted text should be stored in a temporary `draft_content` field or a `pending_recipe` table before it is parsed into structured ingredients. This allows the user to review the cleanup results before the system attempts to populate the structured `RecipeVersion`.

2. How should we handle "non-scalable" ingredients (US-004) in the schema?

Recommendation: Add a `is_scalable` boolean column to the `RecipeIngredient` table. Ingredients flagged as `false` (e.g., "salt to taste") will be preserved in their raw text form during scaling operations, ensuring the final recipe remains coherent.

3. Given the "80% parse gate" requirement, how should the system track which specific lines in a recipe failed to parse?

Recommendation: Store a `parse_errors` JSON column in the `RecipeVersion` or a draft entity. This should map the line index to a specific error message or status, allowing the "Guided Correction" UI (US-005) to highlight the exact lines for the user to fix.

4. Should the `target_calories_per_serving` (PRD 3.2) be a hard constraint or a preference in the schema?

Recommendation: Store it as a `nullable` integer in the `UserPreference` table. In the `RecipeVersion` metadata, also store the `target_at_creation` value. This helps in auditing why a certain version was generated and if the "Unrealistic Targets" warning (US-014) was triggered during that specific tailoring event.

5. How should the "Calories unavailable" status (PRD 3.6) be represented in the database?

Recommendation: Use a `calorie_status` enum (Calculated, Unavailable, In_Progress) and a nullable `calories_total` field on the `RecipeVersion`. If the AI process exceeds 8 seconds, the status is updated to `Unavailable`, but the scaled recipe is still preserved and displayed.

6. What is the most efficient way to handle "Search by Keyword" in ingredients (US-012) across thousands of `RecipeVersion` records?

Recommendation: Since searching every version might be slow, only index the ingredients of the *current* version of each recipe. Use a trigger or application logic to update a `denormalized_ingredients_search` text column on the `Recipe` table whenever the `current_version_id` changes.

7. How should the "Metric and US unit systems" toggle (US-002) affect existing recipes in the database?

Recommendation: The unit system should be a display preference in `UserPreference`. The database should store the values as they were originally entered or parsed. Conversion logic should happen in the Application/Presentation layer to avoid destructive data loss from repeated rounding during toggle changes.

8. For data retention of the `Events` table (30â€“90 days), how should the cleanup be triggered in a MariaDB environment?

Recommendation: Use a MariaDB Event Scheduler or a Symfony Console command (e.g., `app:cleanup-events`) scheduled via a system cron. This command should run daily to delete rows where `created_at < NOW() - INTERVAL 90 DAY`.

9. How should we handle the "Parent-Child" relationship for "Save as New" vs "Overwrite" (US-010)?

Recommendation: "Overwrite" creates a new `RecipeVersion` linked to the same `Recipe` and updates the `current_version_id`. "Save as New" creates a new `Recipe` entity with its own first `RecipeVersion`. Both should optionally store a `source_recipe_id` to allow for "cloned from" lineage tracking.

10. Should the AI's "Keep-it-similar" constraints (protein/method/flavor) be stored as distinct flags?

Recommendation: Yes, store `keep_protein`, `keep_method`, and `keep_flavor` as boolean flags on the `RecipeVersion`. This allows the UI to show the user which constraints were active during tailoring and permits the AI to receive clear instructions on what it is allowed to modify.
</questions>

<answers>
1. The auto-formatted text should be stored in a temporary `draft_content` field or a `pending_recipe` table before it is parsed into structured ingredients. This allows the user to review the cleanup results before the system attempts to populate the structured `RecipeVersion`.
2. Add a `is_scalable` boolean column to the `RecipeIngredient` table. Ingredients flagged as `false` (e.g., "salt to taste") will be preserved in their raw text form during scaling operations, ensuring the final recipe remains coherent.
3. Store a `parse_errors` JSON column in the `RecipeVersion` or a draft entity. This should map the line index to a specific error message or status, allowing the "Guided Correction" UI (US-005) to highlight the exact lines for the user to fix.
4. Store it as a `nullable` integer in the `UserPreference` table. In the `RecipeVersion` metadata, also store the `target_at_creation` value. This helps in auditing why a certain version was generated and if the "Unrealistic Targets" warning (US-014) was triggered during that specific tailoring event.
5. Use a `calorie_status` enum (Calculated, Unavailable, In_Progress) and a nullable `calories_total` field on the `RecipeVersion`. If the AI process exceeds 8 seconds, the status is updated to `Unavailable`, but the scaled recipe is still preserved and displayed.
6. Since searching every version might be slow, only index the ingredients of the *current* version of each recipe. Use a trigger or application logic to update a `denormalized_ingredients_search` text column on the `Recipe` table whenever the `current_version_id` changes.
7. The unit system should be a display preference in `UserPreference`. The database should store the values as they were originally entered or parsed. Conversion logic should happen in the Application/Presentation layer to avoid destructive data loss from repeated rounding during toggle changes.
8. Use a Symfony Console command (e.g., `app:cleanup-events`) scheduled via a system cron. This command should run daily to delete rows where `created_at < NOW() - INTERVAL 90 DAY`.
9. "Overwrite" creates a new `RecipeVersion` linked to the same `Recipe` and updates the `current_version_id`. "Save as New" creates a new `Recipe` entity with its own first `RecipeVersion`. Both should optionally store a `source_recipe_id` to allow for "cloned from" lineage tracking.
10. Yes, store `keep_protein`, `keep_method`, and `keep_flavor` as boolean flags on the `RecipeVersion`. This allows the UI to show the user which constraints were active during tailoring and permits the AI to receive clear instructions on what it is allowed to modify.
</answers>


You are an AI assistant whose task is to summarize the conversation about database planning for MVP and prepare a concise summary for the next stage of development. In the conversation history, you will find the following information:
1. Product Requirements Document (PRD)
2. Information about the tech stack
3. Conversation history containing questions and answers
4. Model recommendations

Your tasks are:
1. Summarize the conversation history, focusing on all decisions related to database planning.
2. Match model recommendations to the answers given in the conversation history. Identify which recommendations are relevant based on the discussion.
3. Prepare a detailed conversation summary that includes:
   a. Main requirements for the database schema
   b. Key entities and their relationships
   c. Important security and scalability concerns
   d. Any unresolved issues or areas requiring further clarification
4. Format the results as follows:

<conversation_summary>
<decisions>
[List decisions made by the user, numbered].
</decisions>

<matched_recommendations>
[List of the most relevant recommendations matched to the conversation, numbered]
</matched_recommendations>

<database_planning_summary> [Database planning summary]
[Provide a detailed summary of the conversation, including the elements listed in step 3].
</database_planning_summary>

<unresolved_issues>
[List any unresolved issues or areas requiring further clarification, if any exist]
</unresolved_issues>
</conversation_summary>

The final output should contain only the content in markdown format. Ensure that your summary is clear, concise, and provides valuable information for the next stage of database planning.
