1. What is the *primary pain* we’re solving for weight-loss users: **speed**, **accuracy of calorie estimates**, **keeping taste similar**, or **reducing decision fatigue**?

Recommendation: Pick 1 primary + 1 secondary “job-to-be-done” and make tradeoffs explicit (e.g., optimize for “fast tailoring that stays similar,” even if calorie estimates are approximate).

2. What does “Reduce calories” *optimize for* when tradeoffs conflict: **hit target calories/serving**, **minimize ingredient changes**, **preserve taste**, or **preserve cooking time/complexity**?

Recommendation: Define an explicit optimization order (e.g., preserve core method/protein → minimize changes within aggressiveness thresholds → then chase calorie target) and encode it into acceptance criteria.

3. What are the exact rules for “Favorites”: is it a **boolean favorite**, a **pinned list with ordering**, or **collections**—and does it affect onboarding/success metrics?

Recommendation: MVP = simple boolean favorite + “Favorites” filter; defer ordering/collections unless browsing reuse is a key retention lever in week-1 analytics.

4. What is the intended “guided user correction” UX when parsing ingredients fails (e.g., inline edits, unit picker, quantity stepper), and what is the *max correction time* we’ll tolerate before users drop?

Recommendation: Use a fast, structured correction UI: one ingredient per row with editable quantity/unit/item + confidence highlights; cap to “fix top N low-confidence lines” and allow “save draft + finish later.”

5. What are the concrete **latency** and **cost** budgets (P50/P95) for each pipeline stage (parse, scale, rewrite+estimate), and what’s the weekly **usage cap** per user?

Recommendation: Set hard budgets now (e.g., P95 < X seconds; max Y tailors/week) and define fallback behavior under load (serve cached parse, skip rewrite, or return scaled-only output with clear labeling).

6. How should we handle **unit ambiguity** and **unsupported units** (e.g., “1 can,” “1 packet,” “to taste,” “a pinch”), and are we okay with leaving some quantities unchanged?

Recommendation: Define a canonical strategy: convert when confident; otherwise preserve raw_text and mark as “not scaled” with low confidence, while still scaling numeric items deterministically.

7. What is the localization scope beyond Metric/US (UI language, ingredient name translation, decimal separators, Polish locale specifics), and is English-only acceptable for MVP?

Recommendation: Lock MVP to UI language = English (or Polish + English) with locale-aware formatting (decimal separators) and unit toggles; treat full ingredient translation as out-of-scope until validated by usage.

8. What are the exact persistence rules: when users choose “Overwrite existing,” do we keep a hidden revision history, and how do we prevent accidental loss?

Recommendation: Always create a new version record under the hood; “Overwrite” becomes “set latest pointer,” enabling undo/restore without expanding the visible UI.

9. What are the “failure handling” policies: retry limits, partial results, and what gets saved when steps fail (e.g., parse succeeded but rewrite failed)?

Recommendation: Specify a deterministic failure matrix:

* If parse fails → guided correction required before tailoring.
* If rewrite fails → return scaled recipe + “calories unavailable” + retry CTA.
* If calorie estimate fails → still return recipe with “estimate unavailable” label.
  Log each failure path as distinct events.

10. What is the analytics stack and retention policy (vendor choice, event schema versioning, PII handling), and who owns metric review cadence?

Recommendation: Choose an MVP stack (e.g., PostHog/Amplitude/GA4) and define: event naming, required properties (mode, aggressiveness, confidence, latency), retention period, and a weekly metrics review ritual with a single accountable owner.


------------------------------------ Answers -----------------------------------------

1. Pick 1 primary + 1 secondary “job-to-be-done” and make tradeoffs explicit (e.g., optimize for “fast tailoring that stays similar,” even if calorie estimates are approximate).
2. Define an explicit optimization order (e.g., preserve core method/protein → minimize changes within aggressiveness thresholds → then chase calorie target) and encode it into acceptance criteria.
3. MVP = simple boolean favorite + “Favorites” filter; defer ordering/collections unless browsing reuse is a key retention lever in week-1 analytics.
4. Keep it simple in MVP, raw edit only
5. Set hard budgets now (e.g., P95 < X seconds; max Y tailors/week) and define fallback behavior under load (serve cached parse, skip rewrite, or return scaled-only output with clear labeling).
6. Define a canonical strategy: convert when confident; otherwise preserve raw_text and mark as “not scaled” with low confidence, while still scaling numeric items deterministically.
7. Lock MVP to UI language = English with locale-aware formatting (decimal separators) and unit toggles; treat full ingredient translation as out-of-scope until validated by usage.
8. Always create a new version record under the hood; “Overwrite” becomes “set latest pointer,” enabling undo/restore without expanding the visible UI.
9. Specify a deterministic failure matrix:

* If parse fails → guided correction required before tailoring.
* If rewrite fails → return scaled recipe + “calories unavailable” + retry CTA.
* If calorie estimate fails → still return recipe with “estimate unavailable” label.
  Log each failure path as distinct events.

10. No MVP Stack here, just keep data without analitics on start