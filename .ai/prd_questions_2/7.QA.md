1. What are the **exact acceptance criteria** for “fast tailoring” (Primary): which user-visible checkpoints must complete under the P95 budgets (e.g., time-to-first-output vs end-to-end), and what must happen when budgets are exceeded?

Recommendation: Define “fast” as **end-to-end P95 ≤ 8s** with a secondary UX metric **time-to-first-result ≤ 2s** (e.g., show “Scaled recipe ready” while rewrite runs); if timeout, trigger fallback matrix and still return *something*.

2. What is the definitive rule set for “stays similar” (Secondary): how do we algorithmically identify **primary protein** and **core flavor base**, and what are the hard constraints vs soft preferences?

Recommendation: Add a deterministic heuristic layer: detect primary protein from ingredient categories + quantity dominance; define core flavor base as top N aromatics/sauces/spices; encode “never remove” as hard constraints unless user disables keep-similar.

3. How do we count “ingredient changes” against the aggressiveness thresholds (≤3/6/10): is it **line-level**, **item-level**, or **semantic** (e.g., olive oil → yogurt counts as 1, splitting counts as 1 or 2)?

Recommendation: Define a strict counting spec: **one change per ingredient line-item** for replace/remove/add; quantity-only adjustments don’t count as “change” unless it alters ingredient identity.

4. What is “N” in the parse gate (“no more than N unknown units”), and what is the explicit definition of an “unknown unit”?

Recommendation: Set **N = 2** for MVP and define unknown unit as anything not in the allowed unit dictionary for the selected locale; provide a short allowlist and treat “can/pack” as “non-scalable marker” rather than unknown.

5. What is the required behavior for steps when scaling: which “critical step parameters” are we allowed to update (time, temperature, pan size), and when do we refuse to edit steps?

Recommendation: Restrict step edits to **obvious numeric multipliers** (e.g., “bake 20 min” stays same; “makes 12 cookies” becomes “makes 24” if servings doubled) and never change temps; add a rule: “if uncertain, do not edit steps.”

6. What is the MVP caching strategy and invalidation rules: what keys are used (recipe hash + locale + unit preference), and when do we re-parse vs reuse cached parse?

Recommendation: Cache parsed ingredients by **normalized recipe text hash + unit system + locale**; invalidate on any ingredient-line edit; reuse cache for repeated tailors to meet latency/cost goals.

7. What is the exact output contract for calorie estimation when accuracy is de-prioritized: how do we present confidence, and what do we show when estimate is unavailable?

Recommendation: Standardize metadata block: **Estimated calories: total + per serving + confidence (low/med/high)**; if unavailable, show **“Calories: unavailable (retry)”** and keep the recipe output intact.

8. What is the minimal security/privacy stance for stored recipes and the internal events table (PII, deletion, export), given Google OAuth and no external analytics vendor?

Recommendation: Define MVP data policy: store only necessary profile fields; events store user_id + timestamps + non-sensitive properties; implement **account delete** and **recipe delete** with cascading removal and event retention honoring 30–90 day policy.

9. What are the MVP success criteria and review queries for the internal events table (exact definitions): how do we compute “weekly tailoring users,” “tailor success rate,” and “profile_complete”?

Recommendation: Lock metric definitions:

* weekly tailoring users = distinct users with **recipe_tailored_success** in last 7 days
* tailor success rate = success / (success + failure) for tailor attempts
* profile_complete = avoid_count ≥ 1 OR target_calories_set = true
  Document the SQL-like queries in PRD.

10. What is the scope of “Undo”: how many prior versions are accessible, and where is it exposed (immediate toast vs history list), given the “no dashboard/minimal UI” posture?

Recommendation: MVP = **single-step undo** (revert latest pointer to previous version) surfaced via toast after overwrite; full version history UI deferred, but keep data model compatible.

------------------------------------ Answers -----------------------------------------

1. Define “fast” as **end-to-end P95 ≤ 8s** with a secondary UX metric **time-to-first-result ≤ 2s** (e.g., show “Scaled recipe ready” while rewrite runs); if timeout, trigger fallback matrix and still return *something*.
2. Add a deterministic heuristic layer: detect primary protein from ingredient categories + quantity dominance; define core flavor base as top N aromatics/sauces/spices; encode “never remove” as hard constraints unless user disables keep-similar.
3. Define a strict counting spec: **one change per ingredient line-item** for replace/remove/add; quantity-only adjustments don’t count as “change” unless it alters ingredient identity.
4. Set **N = 2** for MVP and define unknown unit as anything not in the allowed unit dictionary for the selected locale; provide a short allowlist and treat “can/pack” as “non-scalable marker” rather than unknown.
5. Restrict step edits to **obvious numeric multipliers** (e.g., “bake 20 min” stays same; “makes 12 cookies” becomes “makes 24” if servings doubled) and never change temps; add a rule: “if uncertain, do not edit steps.”
6. Cache parsed ingredients by **normalized recipe text hash + unit system + locale**; invalidate on any ingredient-line edit; reuse cache for repeated tailors to meet latency/cost goals.
7. Standardize metadata block: **Estimated calories: total + per serving + confidence (low/med/high)**; if unavailable, show **“Calories: unavailable (retry)”** and keep the recipe output intact.
8. Define MVP data policy: store only necessary profile fields; events store user_id + timestamps + non-sensitive properties; implement **account delete** and **recipe delete** with cascading removal and event retention honoring 30–90 day policy.
9. Lock metric definitions:

* weekly tailoring users = distinct users with **recipe_tailored_success** in last 7 days
* tailor success rate = success / (success + failure) for tailor attempts
* profile_complete = avoid_count ≥ 1 OR target_calories_set = true
  Document the SQL-like queries in PRD.
10. MVP = **single-step undo** (revert latest pointer to previous version) surfaced via toast after overwrite; full version history UI deferred, but keep data model compatible.